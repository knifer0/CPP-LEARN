#include <stdio.h>
void print(int *t, int r){
	for(int i=0; i<r; i++)
		printf("%d ",*(t+i));
}
void stworzKopiec(int *t, int n);
void naprawKopiec(int *t, int heapSize, int parentIndex);
void swap(int *a, int *b){
	int temp;
	temp = *a;
	*a = *b; 
	*b = temp;
}
int main(void){
	int tab[10] = {9,7,4,3,6,5,1,2,8,11};
    print(tab,10);
    puts("");
    stworzKopiec(tab,10);
    print(tab,10);
	return 0;
}
void stworzKopiec(int *t, int n){
	int temp;
	for(int i=n/2-1; i>=0; i--){ // zaczynamy od ostatniego rodzica, którego znajdziemy jeśli podzielimy ilość elemtnów/2 -1
		naprawKopiec(t,n,i); 
	}							 // !!!!!!!!!!!!!!!!!!! ZACZYNAMY SPRAWDZAĆ OD DOŁU TYLKO W MOMENCIE ZBUDOWANIA KOPCA, PÓŹNIEJ ZAWSZE OD GÓRY, JAK PONIŻEJ //
	for(int i=n-1; i>0; i--){
		swap(&t[i],&t[0]); // zamieniamy ostatni element tablicy z rootem
		naprawKopiec(t,--n,0); // odcinamy ostatnią gałąż drzewa i zaczynamy sprawdzać od góry 
	}
}
void naprawKopiec(int *t, int heapSize, int parentIndex){
	int  temp;
	int maxIndex = parentIndex; 
	int leftChild = parentIndex*2+1; // lewe dziecko ze wzoru 2k+1
	int rightChild = parentIndex*2+2; // prawe dziecko ze wzoru 2k+2
	if(leftChild < heapSize && t[leftChild] > t[maxIndex]){
		maxIndex = leftChild;
	}
	if(rightChild <heapSize && t[rightChild] > t[maxIndex]){
		maxIndex = rightChild;
	}
	if(maxIndex!=parentIndex){ // jeżeli dziecko jest większe od rodzica zamieniamy, wywołujemy tą samą funkcję dla drzewa poniżej 
		swap(&t[maxIndex],&t[parentIndex]);
		naprawKopiec(t,heapSize,maxIndex);
	}
}